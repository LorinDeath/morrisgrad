---
---
<div class="arcade-layout">
    <div class="game-wrapper">
        <canvas id="mini-game-canvas" width="600" height="600"></canvas>
        <div id="game-overlay" class="overlay">
            <div class="message">Нажми, чтобы играть</div>
            <div class="sub-message">Поймай точку! У тебя 30 секунд.</div>
        </div>
        
        <!-- Экран Game Over -->
        <div id="input-overlay" class="overlay hidden">
            <div class="game-over-content">
                <div class="message">Новый рекорд!</div>
                <div class="final-score">Твой счет: <span id="final-score-val">0</span></div>
                
                <div class="input-group">
                    <input type="text" id="player-name" minlength="2" maxlength="6" placeholder="NAME" />
                    <div class="hint">2-6 латинских букв</div>
                </div>
                
                <button id="submit-score-btn" class="action-btn">Отправить рекорд</button>
            </div>
        </div>

        <!-- Pre-Submit: Спросить, хочет ли игрок сохранить рекорд -->
        <div id="pre-submit-overlay" class="overlay hidden">
            <div class="dialog-box">
                <div id="pre-submit-message" class="message">Вы попали в топ-5!</div>
                <div class="sub-message">Хотите записать свой рекорд?</div>
                <div class="button-group">
                    <button id="pre-submit-yes-btn" class="action-btn">Да</button>
                    <button id="pre-submit-no-btn" class="restart-btn">Нет</button>
                </div>
            </div>
        </div>

        <!-- Post-Submit: Спросить, хочет ли игрок играть снова -->
        <div id="post-submit-overlay" class="overlay hidden">
            <div class="dialog-box">
                <div id="post-submit-message" class="message">Вы молодец!</div>
                <div id="post-submit-sub-message" class="sub-message">Ваш рекорд записан. Играть снова?</div>
                <div class="button-group">
                    <button id="post-submit-yes-btn" class="action-btn">Да</button>
                    <button id="post-submit-no-btn" class="restart-btn">Нет</button>
                </div>
            </div>
        </div>

        <!-- Glitch Overlay -->
        <div id="glitch-overlay" class="overlay hidden glitch">
            <div class="message" data-text="Жаль">Жаль</div>
        </div>

        <!-- Loading Overlay -->
        <div id="loading-overlay" class="overlay hidden">
            <div class="message">Связь с сервером...</div>
            <div class="sub-message">Сверяем результаты</div>
        </div>
    </div>

    <!-- Таблица рекордов -->
    <div class="leaderboard-section">
        <div class="lb-column">
            <h3>Топ за день</h3>
            <table class="score-table">
                <thead>
                    <tr>
                        <th>Ник</th>
                        <th class="text-right">Счет</th>
                    </tr>
                </thead>
                <tbody id="daily-list"><tr><td colspan="2">Загрузка...</td></tr></tbody>
            </table>
        </div>
        <div class="lb-column">
            <h3>Топ за неделю</h3>
            <table class="score-table">
                <thead>
                    <tr>
                        <th>Ник</th>
                        <th class="text-right">Счет</th>
                    </tr>
                </thead>
                <tbody id="weekly-list"><tr><td colspan="2">Загрузка...</td></tr></tbody>
            </table>
        </div>
    </div>
</div>

<style>
    .arcade-layout {
        display: flex;
        justify-content: center;
        align-items: flex-start;
        gap: 2rem;
        flex-wrap: wrap;
        margin: 2rem 0;
    }

    .game-wrapper {
        width: 100%;
        max-width: 500px; /* Ограничим ширину, чтобы не было слишком огромным */
        aspect-ratio: 1 / 1;
        margin: 0;
        position: relative;
        background-color: #111;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        border: 1px solid rgba(255,255,255,0.1);
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
        cursor: crosshair;
    }

    .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0,0,0,0.7);
        transition: opacity 0.3s ease;
        cursor: pointer;
        z-index: 10;
        flex-direction: column;
        gap: 1rem;
    }

    .overlay.hidden {
        opacity: 0;
        pointer-events: none;
    }

    .message {
        color: white;
        font-size: 1.5rem;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 2px;
        user-select: none;
        text-align: center;
    }

    .sub-message {
        color: #ccc;
        font-size: 1rem;
    }

    .game-over-content, .dialog-box {
        background: rgba(10, 10, 10, 0.9);
        padding: 2rem;
        border-radius: 12px;
        border: 1px solid var(--accent-gold, #ffd700);
        text-align: center;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
    }

    .final-score {
        font-size: 1.2rem;
        color: var(--accent-gold, #ffd700);
        margin-bottom: 1rem;
    }

    .input-group {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }

    input {
        background: #222;
        border: 1px solid #444;
        color: #fff;
        padding: 10px;
        border-radius: 6px;
        text-align: center;
        font-size: 1.2rem;
        letter-spacing: 3px;
        text-transform: uppercase;
        outline: none;
    }
    input:focus { border-color: var(--accent-gold, #ffd700); }

    .hint { font-size: 0.8rem; color: #666; }

    .action-btn {
        background: var(--accent-gold, #ffd700);
        color: #000;
        border: none;
        padding: 10px;
        border-radius: 6px;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s;
    }
    .action-btn:hover { transform: scale(1.05); }
    .action-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .restart-btn {
        background: transparent;
        color: #fff;
        border: 1px solid #444;
        padding: 8px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
    }
    .restart-btn:hover { border-color: #fff; }
    
    .button-group {
        display: flex;
        justify-content: center;
        gap: 1rem;
        margin-top: 1rem;
    }

    /* Glitch Effect */
    .glitch .message {
        position: relative;
        text-shadow: 0.05em 0 0 rgba(255, 0, 0, 0.75), -0.05em 0 0 rgba(0, 255, 0, 0.75), 0 0.05em 0 rgba(0, 0, 255, 0.75);
        animation: glitch 500ms infinite;
    }
    .glitch .message::before, .glitch .message::after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(10, 10, 10, 0.9);
        overflow: hidden;
        animation: glitch-move 2s infinite ease-out;
    }
    .glitch .message::before {
        clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
        transform: translate(-0.05em, -0.025em);
        color: red;
    }
    .glitch .message::after {
        clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
        transform: translate(0.05em, 0.025em);
        color: blue;
    }
    @keyframes glitch {
        0% { text-shadow: 0.05em 0 0 rgba(255, 0, 0, 0.75), -0.05em 0 0 rgba(0, 255, 0, 0.75), 0 0.05em 0 rgba(0, 0, 255, 0.75); }
        14% { text-shadow: 0.05em 0 0 rgba(255, 0, 0, 0.75), -0.05em 0 0 rgba(0, 255, 0, 0.75), 0 0.05em 0 rgba(0, 0, 255, 0.75); }
        15% { text-shadow: -0.05em -0.025em 0 rgba(255, 0, 0, 0.75), 0.025em 0.025em 0 rgba(0, 255, 0, 0.75), -0.05em -0.05em 0 rgba(0, 0, 255, 0.75); }
        49% { text-shadow: -0.05em -0.025em 0 rgba(255, 0, 0, 0.75), 0.025em 0.025em 0 rgba(0, 255, 0, 0.75), -0.05em -0.05em 0 rgba(0, 0, 255, 0.75); }
        50% { text-shadow: 0.025em 0.05em 0 rgba(255, 0, 0, 0.75), 0.05em 0 0 rgba(0, 255, 0, 0.75), 0 -0.05em 0 rgba(0, 0, 255, 0.75); }
        99% { text-shadow: 0.025em 0.05em 0 rgba(255, 0, 0, 0.75), 0.05em 0 0 rgba(0, 255, 0, 0.75), 0 -0.05em 0 rgba(0, 0, 255, 0.75); }
        100% { text-shadow: -0.025em 0 0 rgba(255, 0, 0, 0.75), -0.025em -0.025em 0 rgba(0, 255, 0, 0.75), -0.025em -0.05em 0 rgba(0, 0, 255, 0.75); }
    }
     @keyframes glitch-move {
        2% { transform: translate(0.05em, -0.05em); }
        4% { transform: translate(-0.05em, 0.05em); }
        6% { transform: translate(0.05em, 0.05em); }
        8% { transform: translate(-0.05em, -0.05em); }
        10% { transform: translate(0, 0); }
    }

    /* Стили таблицы рекордов */
    .leaderboard-section {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        width: 280px;
        flex-shrink: 0;
    }
    .lb-column {
        background: #1a1a1a;
        padding: 1rem;
        border-radius: 4px;
        border: 2px solid #333;
        box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        font-family: 'Courier New', Courier, monospace;
    }
    .lb-column h3 {
        color: #aaa;
        font-size: 1.1rem;
        text-align: center;
        margin: 0 0 0.5rem 0;
        border-bottom: 1px solid #444;
        padding-bottom: 0.5rem;
        text-transform: uppercase;
    }
    .score-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.95rem;
    }
    .score-table th {
        text-align: left;
        color: #666;
        font-weight: normal;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #444;
    }
    .score-table td {
        padding: 0.5rem 0;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .text-right { text-align: right; }
    .score-name { font-weight: bold; color: #fff; }
    .score-val { color: var(--accent-gold, #ffd700); font-weight: bold; }
    .empty-msg { color: #666; text-align: center; font-style: italic; padding: 1rem 0; }
    
    @media (max-width: 600px) {
        .arcade-layout {
            flex-direction: column;
            align-items: center;
        }
        .leaderboard-section { width: 100%; max-width: 500px; }
    }
</style>

<script>
    // Оборачиваем код в astro:page-load, чтобы он запускался при каждом переходе
    document.addEventListener('astro:page-load', () => {
        const canvas = document.getElementById('mini-game-canvas') as HTMLCanvasElement;
        // Если на текущей странице нет игры, ничего не делаем
        if (!canvas) return;

        const overlay = document.getElementById('game-overlay');
        const gameOverOverlay = document.getElementById('input-overlay');
        const finalScoreSpan = document.getElementById('final-score-val');
        const nameInput = document.getElementById('player-name') as HTMLInputElement;
        const submitBtn = document.getElementById('submit-score-btn') as HTMLButtonElement;
        const dailyList = document.getElementById('daily-list');
        const weeklyList = document.getElementById('weekly-list');
        
        // Новые элементы
        const preSubmitOverlay = document.getElementById('pre-submit-overlay');
        const postSubmitOverlay = document.getElementById('post-submit-overlay');
        const glitchOverlay = document.getElementById('glitch-overlay');
        const loadingOverlay = document.getElementById('loading-overlay');
        const preSubmitMessage = document.getElementById('pre-submit-message');
        const postSubmitMessage = document.getElementById('post-submit-message');
        const postSubmitSubMessage = document.getElementById('post-submit-sub-message');
        
        let dailyData: any[] = [];
        let weeklyData: any[] = [];
        let difficultyMultiplier = 1;

    // Загрузка рекордов
    async function fetchScores() {
        try {
            const res = await fetch('/api/scores');
            if (!res.ok) {
                throw new Error(`Ошибка ${res.status}`);
            }
            const data = await res.json();
            dailyData = data.daily || [];
            weeklyData = data.weekly || [];
            renderList(dailyList, data.daily);
            renderList(weeklyList, data.weekly);
        } catch (e) {
            console.error("Не удалось загрузить рекорды", e);
            // Показываем сообщение в таблице, если API недоступно
            const errMsg = '<tr><td colspan="2" class="empty-msg">Нет связи с сервером</td></tr>';
            if (dailyList) dailyList.innerHTML = errMsg;
            if (weeklyList) weeklyList.innerHTML = errMsg;
        }
    }

    function renderList(el: HTMLElement | null, items: any[]) {
        if (!el) return;
        el.innerHTML = '';
        if (!items || items.length === 0) {
            el.innerHTML = '<tr><td colspan="2" class="empty-msg">Пока пусто</td></tr>';
            return;
        }
        items.forEach(item => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td class="score-name">${item.name}</td><td class="score-val text-right">${item.score}</td>`;
            el.appendChild(tr);
        });
    }

    // Инициализация при загрузке
    fetchScores();

    if (canvas && overlay && gameOverOverlay) {
        const ctx = canvas.getContext('2d')!;
        let isPlaying = false;
        let score = 0;
        let timeLeft = 30;
        let maxTime = 30;
        let lastTime = 0;
        let lastTeleportTime = 0;
        let teleportInterval = 4000;
        let clicks: {x: number, y: number, radius: number, alpha: number}[] = [];
        let hits: {x: number, y: number, size: number, alpha: number, color?: string}[] = [];
        let decoys: {x: number, y: number, size: number}[] = [];
        let nextPhantomTime = 0;
        
        // Цель теперь золотая, под стиль сайта
        const target = { x: 100, y: 100, size: 10, color: '#ffd700' };
        
        let mouseX = 0;
        let mouseY = 0;

        function startGame() {
            if (isPlaying) return;
            
            isPlaying = true;
            score = 0;
            timeLeft = 30 * difficultyMultiplier;
            maxTime = timeLeft;
            lastTime = performance.now();
            lastTeleportTime = performance.now();
            clicks = []; // Сброс старых кликов
            hits = [];   // Сброс старых попаданий
            decoys = []; // Сброс ловушек
            nextPhantomTime = performance.now() + getRandomPhantomInterval();
            
            overlay!.classList.add('hidden');
            gameOverOverlay?.classList.add('hidden');
            postSubmitOverlay?.classList.add('hidden');
            glitchOverlay?.classList.add('hidden');
            loadingOverlay?.classList.add('hidden');
            
            spawnTarget();
            requestAnimationFrame(draw);
        }

        function getRandomPhantomInterval() {
            if (difficultyMultiplier < 4) return 99999999;
            
            const levels = Math.log2(difficultyMultiplier) - 2; // x4->0, x8->1
            const divisor = Math.pow(2, levels);
            
            let min = 5000 / divisor;
            let max = 15000 / divisor;
            
            if (min < 500) min = 500;
            if (max < 1000) max = 1000;
            
            return Math.random() * (max - min) + min;
        }

        function spawnTarget() {
            // Размер зависит от фазы игры (времени)
            let minSize, maxSize;
            if (timeLeft > 20 * difficultyMultiplier) {
                minSize = 50; maxSize = 100;
            } else if (timeLeft > 10 * difficultyMultiplier) {
                minSize = 30; maxSize = 50;
            } else {
                minSize = 20; maxSize = 30;
            }

            // Уменьшаем размер в 1.3 раза за каждый уровень сложности
            const sizeDivisor = Math.pow(1.2, Math.log2(difficultyMultiplier));
            minSize = Math.max(3, Math.floor(minSize / sizeDivisor));
            maxSize = Math.max(5, Math.floor(maxSize / sizeDivisor));

            target.size = Math.floor(Math.random() * (maxSize - minSize + 1)) + minSize;
            // Позиция с учетом размера, чтобы не вылезала за край
            target.x = Math.random() * (canvas.width - target.size * 2) + target.size;
            target.y = Math.random() * (canvas.height - target.size * 2) + target.size;

            // Ловушки (Decoys) появляются с x2 сложности
            decoys = [];
            if (difficultyMultiplier >= 2) {
                const decoyCount = Math.floor(Math.log2(difficultyMultiplier)); // x2=1, x4=2, x8=3
                for (let i = 0; i < decoyCount; i++) {
                    decoys.push({
                        x: Math.random() * (canvas.width - target.size * 2) + target.size,
                        y: Math.random() * (canvas.height - target.size * 2) + target.size,
                        size: target.size
                    });
                }
            }
        }

        async function gameOver() {
            if (!isPlaying) return; // Защита от двойного вызова
            isPlaying = false;
            if (finalScoreSpan) finalScoreSpan.textContent = score.toString();

            // Показываем загрузку перед проверкой
            loadingOverlay?.classList.remove('hidden');
            await fetchScores(); // Ждем свежие данные с сервера
            loadingOverlay?.classList.add('hidden');
            
            // Проверка на топ-5
            const minDaily = dailyData.length < 5 ? 0 : dailyData[dailyData.length - 1].score;
            const minWeekly = weeklyData.length < 5 ? 0 : weeklyData[weeklyData.length - 1].score;
            
            const isDailyTop = score > minDaily;
            const isWeeklyTop = score > minWeekly;
            
            if (isDailyTop || isWeeklyTop) {
                let text = "Вы попали в топ 5";
                if (isDailyTop && isWeeklyTop) text += " дня и недели!";
                else if (isDailyTop) text += " дня!";
                else text += " недели!";

                if (preSubmitMessage) preSubmitMessage.textContent = text;
                preSubmitOverlay?.classList.remove('hidden');
            } else {
                if (postSubmitMessage) postSubmitMessage.textContent = "Увы, вы не побили рекорд";
                if (postSubmitSubMessage) postSubmitSubMessage.textContent = "Начать заново?";
                postSubmitOverlay?.classList.remove('hidden');
            }
        }

        function draw(timestamp: number) {
            if (!isPlaying) return;

            const now = performance.now();
            // Таймер
            if (timestamp - lastTime >= 1000) {
                timeLeft--;
                lastTime = timestamp;
                if (timeLeft <= 0) {
                    gameOver();
                    return;
                }
            }

            // Логика сложности (интервалы перемещения)
            // Первые 20 сек (60-40): 2 сек
            // Следующие 20 сек (40-20): 1 сек
            // Следующие 10 сек (20-10): 0.5 сек
            // Последние 10 сек (10-0): 0.2 сек
            let isBonusPhase = false;
            
            // Уменьшаем интервал в 1.5 раза за каждый уровень сложности
            const intervalDivisor = Math.pow(1.4, Math.log2(difficultyMultiplier));
            
            if (timeLeft > 20 * difficultyMultiplier) {
                teleportInterval = 4000 / intervalDivisor;
            } else if (timeLeft > 10 * difficultyMultiplier) {
                teleportInterval = 3000 / intervalDivisor;
            } else {
                isBonusPhase = true; // Двойные очки
                if (timeLeft > 5 * difficultyMultiplier) {
                    teleportInterval = 2000 / intervalDivisor;
                } else {
                    teleportInterval = 1500 / intervalDivisor;
                }
            }

            // Автоматическое перемещение точки
            if (now - lastTeleportTime > teleportInterval) {
                spawnTarget();
                lastTeleportTime = now;
            }

            // Фантомные нажатия (пугалки) для x4 и выше
            if (difficultyMultiplier >= 4 && now > nextPhantomTime) {
                const px = Math.random() * (canvas.width - 60) + 30;
                const py = Math.random() * (canvas.height - 60) + 30;
                // Добавляем визуальный эффект "попадания в ловушку" (красный), но без штрафа
                hits.push({ x: px, y: py, size: target.size, alpha: 1.0, color: '#ef4444' });
                
                nextPhantomTime = now + getRandomPhantomInterval();
            }

            // Отрисовка фона
            if (difficultyMultiplier >= 16) {
                // На x16 оставляем шлейф (Motion Blur), не стирая фон полностью
                ctx.fillStyle = 'rgba(10, 10, 10, 0.25)';
            } else {
                ctx.fillStyle = '#0a0a0a'; // Темный фон сайта
            }
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Отрисовка эффектов клика (расходящиеся круги)
            // Рисуем их ДО гличей и ловушек, чтобы они были на заднем плане
            ctx.lineWidth = 2;
            for (let i = clicks.length - 1; i >= 0; i--) {
                const click = clicks[i];
                ctx.beginPath();
                ctx.arc(click.x, click.y, click.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 215, 0, ${click.alpha})`; // Золотой цвет
                ctx.stroke();
                
                click.radius += 4;   // Ускорили расширение (было 2)
                click.alpha -= 0.1;  // Ускорили исчезновение (было 0.05)
                
                if (click.alpha <= 0) clicks.splice(i, 1);
            }

            // Эффект помех (Glitch) для сложности x4 и выше
            const glitchChance = difficultyMultiplier >= 8 ? 0.15 : 0.05;
            if (difficultyMultiplier >= 4 && Math.random() < glitchChance) {
                const h = Math.random() * (difficultyMultiplier >= 8 ? 60 : 20) + 5;
                const y = Math.random() * canvas.height;
                
                // На x8 помехи агрессивнее и разнообразнее
                if (difficultyMultiplier >= 8 && Math.random() > 0.5) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)'; // Матричный шум
                } else {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.15)'; // Красный шум
                }
                ctx.fillRect(0, y, canvas.width, h);

                // Дополнительные полосы для x8 (сбой синхронизации)
                if (difficultyMultiplier >= 8 && Math.random() < 0.3) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx.fillRect(0, Math.random() * canvas.height, canvas.width, 10);
                }
                
                // x16: Дополнительные визуальные искажения (белый шум)
                if (difficultyMultiplier >= 16 && Math.random() < 0.1) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }

            // Отрисовка ловушек (Зеленые со смайликом)
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#22c55e';
            ctx.lineWidth = 2;
            
            for (const d of decoys) {
                // Тело (зеленое)
                ctx.fillStyle = '#22c55e';
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
                ctx.fill();

                // Смайлик
                ctx.strokeStyle = '#000';
                
                // Глаза
                const eyeOffset = d.size * 0.3;
                const eyeSize = d.size * 0.15;
                
                ctx.fillStyle = '#a020f0'; // Левый глаз - Красный
                ctx.beginPath();
                ctx.arc(d.x - eyeOffset, d.y - eyeOffset, eyeSize, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ef4444'; // Правый глаз - Фиолетовый
                ctx.beginPath();
                ctx.arc(d.x + eyeOffset, d.y - eyeOffset, eyeSize, 0, Math.PI * 2);
                ctx.fill();

                // Улыбка
                ctx.beginPath();
                ctx.arc(d.x, d.y, d.size * 0.5, 0.2 * Math.PI, 0.8 * Math.PI);
                ctx.stroke();
            }

            // Отрисовка попаданий (фиолетовая точка с волнами)
            for (let i = hits.length - 1; i >= 0; i--) {
                const hit = hits[i];
                ctx.save();
                ctx.globalAlpha = hit.alpha;
                const hitColor = hit.color || '#a020f0';
                
                // Фиолетовая точка (остается на месте и мешает)
                ctx.fillStyle = hitColor; 
                ctx.beginPath();
                ctx.arc(hit.x, hit.y, hit.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Волны и лучи для отвлечения
                ctx.strokeStyle = hitColor;
                ctx.lineWidth = 2;
                const progress = 1.0 - hit.alpha; // Насколько давно попали (0..1)

                // Расходящиеся волны (3 штуки)
                for(let w = 1; w <= 3; w++) {
                    const waveRadius = hit.size + (progress * 80 * w); 
                    ctx.beginPath();
                    ctx.arc(hit.x, hit.y, waveRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Вращающиеся лучи
                const rays = 8;
                const rayDist = hit.size + 5 + (progress * 80); // Улетают от центра
                const rayLen = 20 + (progress * 60); // И удлиняются
                
                for (let r = 0; r < rays; r++) {
                    const angle = (Math.PI * 2 / rays) * r + (progress * 3); // Вращение
                    const sx = hit.x + Math.cos(angle) * rayDist;
                    const sy = hit.y + Math.sin(angle) * rayDist;
                    const ex = hit.x + Math.cos(angle) * (rayDist + rayLen);
                    const ey = hit.y + Math.sin(angle) * (rayDist + rayLen);
                    
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(ex, ey);
                    ctx.stroke();
                }
                ctx.restore();
                
                hit.alpha -= 0.010; // Очень медленное исчезновение (около 3 сек)
                if (hit.alpha <= 0) hits.splice(i, 1);
            }

            // Цель
            ctx.fillStyle = isBonusPhase ? '#ff4500' : target.color; // Краснеет в конце
            ctx.shadowBlur = 10;
            ctx.shadowColor = ctx.fillStyle;
            ctx.beginPath();
            ctx.arc(target.x, target.y, target.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0; // Сброс свечения

            // Круговой таймер (справа сверху)
            const timerX = canvas.width - 40;
            const timerY = 40;
            const timerRadius = 20;

            // Фон таймера (тусклое кольцо)
            ctx.beginPath();
            ctx.arc(timerX, timerY, timerRadius, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Прогресс таймера (зеленый исчезающий)
            const progress = Math.max(0, timeLeft / maxTime);
            ctx.beginPath();
            ctx.arc(timerX, timerY, timerRadius, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * progress));
            ctx.strokeStyle = timeLeft <= 10 * difficultyMultiplier ? '#ef4444' : '#22c55e';
            ctx.lineWidth = 4;
            ctx.stroke();

            // Инфо внизу (мелким шрифтом)
            ctx.fillStyle = '#888';
            ctx.font = '12px "Exo 2", sans-serif';
            ctx.fillText(`Счет: ${score}   |   Время: ${timeLeft}   |   Сложность: x${difficultyMultiplier}`, 20, canvas.height - 15);

            requestAnimationFrame(draw);
        }

        // Общая функция обработки выстрела
        function processClick(x: number, y: number) {
            clicks.push({ x: x, y: y, radius: 5, alpha: 1.0 });

            // Проверка попадания в ловушки (Decoys)
            for (const d of decoys) {
                const dx = x - d.x;
                const dy = y - d.y;
                if (Math.sqrt(dx*dx + dy*dy) < d.size + 5) {
                    // Штраф!
                    score -= 2 * difficultyMultiplier;
                    hits.push({ x: d.x, y: d.y, size: d.size, alpha: 1.0, color: '#ef4444' }); // Красный взрыв
                    return; // Не проверяем цель, если попали в ловушку
                }
            }

            const dx = x - target.x;
            const dy = y - target.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance < target.size + 5) {
                hits.push({ x: target.x, y: target.y, size: target.size, alpha: 1.0, color: '#a020f0' });
                score += (timeLeft <= 10 * difficultyMultiplier ? 2 : 1) * difficultyMultiplier;
                spawnTarget();
                lastTeleportTime = performance.now();
            }
        }

        // Отслеживание движения мыши
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX;
            mouseY = (e.clientY - rect.top) * scaleY;
        });

        // Обработка клика
        canvas.addEventListener('mousedown', (e) => {
            if (!isPlaying) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clickX = (e.clientX - rect.left) * scaleX;
            const clickY = (e.clientY - rect.top) * scaleY;
            processClick(clickX, clickY);
        });

        // Обработка пробела
        const handleKeydown = (e: KeyboardEvent) => {
            if (!document.body.contains(canvas)) {
                window.removeEventListener('keydown', handleKeydown);
                return;
            }
            if (e.code === 'Space' && isPlaying) {
                e.preventDefault();
                processClick(mouseX, mouseY);
            }
        };
        window.addEventListener('keydown', handleKeydown);

        overlay.addEventListener('click', startGame);

        // Рестарт
        // Логика кнопок
        
        // Pre-Submit: Да (хочу записать)
        document.getElementById('pre-submit-yes-btn')?.addEventListener('click', () => {
            preSubmitOverlay?.classList.add('hidden');
            gameOverOverlay?.classList.remove('hidden'); // Показываем ввод имени (теперь это input-overlay)
        });

        // Pre-Submit: Нет (не хочу)
        document.getElementById('pre-submit-no-btn')?.addEventListener('click', () => {
            preSubmitOverlay?.classList.add('hidden');
            if (postSubmitMessage) postSubmitMessage.textContent = "Рекорд не сохранен";
            if (postSubmitSubMessage) postSubmitSubMessage.textContent = "Начать заново?";
            postSubmitOverlay?.classList.remove('hidden');
        });

        // Post-Submit: Да (играть снова)
        document.getElementById('post-submit-yes-btn')?.addEventListener('click', () => {
            postSubmitOverlay?.classList.add('hidden');
            // Сброс сложности и возвращение в меню (пауза)
            difficultyMultiplier = 1;
            
            // Возвращаем текст на место
            const subMsg = overlay!.querySelector('.sub-message');
            if (subMsg) subMsg.textContent = "Поймай точку! У тебя 30 секунд.";
            
            overlay!.classList.remove('hidden');
        });

        // Post-Submit: Нет (не играть -> Глич -> Хардкор)
        document.getElementById('post-submit-no-btn')?.addEventListener('click', () => {
            postSubmitOverlay?.classList.add('hidden');
            glitchOverlay?.classList.remove('hidden');
        });

        // Glitch Click -> Hardcore Start
        glitchOverlay?.addEventListener('click', () => {
            difficultyMultiplier *= 2;
            glitchOverlay.classList.add('hidden');
            startGame(); // Прямой запуск
        });

        // Отправка формы
        submitBtn?.addEventListener('click', async () => {
            const name = nameInput.value.toUpperCase();
            
            // Валидация
            if (name.length < 2 || name.length > 6) {
                alert("Имя должно содержать от 2 до 6 символов!");
                return;
            }
            if (!/^[A-Z]+$/.test(name)) {
                alert("Только латинские буквы!");
                return;
            }

            submitBtn.disabled = true;
            submitBtn.textContent = "Отправка...";

            try {
                const res = await fetch('/api/scores', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, score })
                });

                const result = await res.json();

                if (res.ok) {
                    await fetchScores(); // Обновить таблицу
                    gameOverOverlay?.classList.add('hidden');
                    if (postSubmitMessage) postSubmitMessage.textContent = "Вы молодцы!";
                    if (postSubmitSubMessage) postSubmitSubMessage.textContent = "Ваш рекорд записан. Начать заново?";
                    postSubmitOverlay?.classList.remove('hidden');
                } else {
                    alert("Ошибка: " + (result.error || res.statusText));
                }
            } catch (e) {
                console.error(e);
                alert("Не удалось соединиться с сервером. Проверьте консоль (F12).");
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = "Отправить рекорд";
            }
        });

        // Начальная отрисовка (фон)
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    });
</script>